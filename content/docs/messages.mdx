---
title: Messages
description: Chat messages component with user and AI bubbles
---

import { MessagesSection } from '@/components/MessagesSection';

<MessagesSection />

```tsx
"use client"

import { useRef, useEffect, useState } from "react";
import { Markdown } from "@/components/prompt-kit/markdown";

export interface Message {
  role: "user" | "assistant";
  content: string;
  reasoning?: string;
  isStreaming?: boolean;
  imageUrl?: string;
}

export interface UserBubbleProps {
  content: string;
  imageUrl?: string;
  index: number;
}

export interface AssistantBubbleProps {
  content: string;
}

export const USER_BUBBLE_CONFIG = {
  width: {
    min: 60,
    maxPercent: 0.85,
    charWidth: 8,
    paddingTotal: 32,
  },
  height: {
    min: 34,
    lineHeight: 21,
    paddingTotal: 16,
    imageMaxHeight: 200,
    imageMarginBottom: 8,
  },
  padding: {
    horizontal: 16,
    vertical: 8,
  },
  borderRadius: {
    bubble: 20,
    image: 8,
  },
  colors: {
    backgroundLight: "#f4f4f4",
    backgroundDark: "#2a2a2a",
    textLight: "#1c1917",
    textDark: "#f5f5f4",
  },
  typography: {
    fontSize: 15,
    fontWeight: 500,
  },
  widthThresholds: [
    { maxChars: 10, widthPercent: 0.15 },
    { maxChars: 30, widthPercent: 0.4 },
    { maxChars: 60, widthPercent: 0.6 },
    { maxChars: 120, widthPercent: 0.8 },
    { maxChars: Infinity, widthPercent: 0.85 },
  ],
};

export const ASSISTANT_CONFIG = {
  typography: {
    fontSize: 15,
    fontWeight: 500,
    lineHeight: 1.6,
  },
  colors: {
    textLight: "#000000",
    textDark: "#ffffff",
  },
};

function estimateTextWidth(text: string): number {
  const { charWidth } = USER_BUBBLE_CONFIG.width;
  let width = 0;
  for (const char of text) {
    if (char === " ") width += charWidth * 0.4;
    else if (char === "\n") continue;
    else if (/[A-Z]/.test(char)) width += charWidth * 1.2;
    else if (/[a-z]/.test(char)) width += charWidth * 0.9;
    else if (/[0-9]/.test(char)) width += charWidth;
    else if (/[!.,;:]/.test(char)) width += charWidth * 0.5;
    else width += charWidth;
  }
  return width;
}

function calculateLineCount(text: string, maxWidth: number): number {
  const lines = text.split("\n");
  let totalLines = 0;
  for (const line of lines) {
    if (line.length === 0) {
      totalLines += 1;
      continue;
    }
    const lineWidth = estimateTextWidth(line);
    totalLines += Math.max(1, Math.ceil(lineWidth / maxWidth));
  }
  return totalLines;
}

function calculateBubbleWidth(textLength: number, containerWidth: number, hasImage: boolean): number {
  const { width, widthThresholds } = USER_BUBBLE_CONFIG;
  const maxAllowed = containerWidth * width.maxPercent;
  if (hasImage) {
    return Math.min(maxAllowed, Math.max(250, textLength * width.charWidth + width.paddingTotal));
  }
  const threshold = widthThresholds.find(t => textLength <= t.maxChars);
  const targetPercent = threshold?.widthPercent ?? 0.85;
  const estimated = textLength * width.charWidth + width.paddingTotal;
  return Math.max(width.min, Math.min(estimated, containerWidth * targetPercent, maxAllowed));
}

function calculateBubbleHeight(text: string, bubbleWidth: number, hasImage: boolean): number {
  const { height, padding } = USER_BUBBLE_CONFIG;
  const contentWidth = bubbleWidth - padding.horizontal * 2;
  const lineCount = calculateLineCount(text, contentWidth);
  let totalHeight = height.paddingTotal + lineCount * height.lineHeight;
  if (hasImage) {
    totalHeight += height.imageMaxHeight + height.imageMarginBottom;
  }
  return Math.max(height.min, totalHeight);
}

function isDarkMode(): boolean {
  if (typeof document === "undefined") return false;
  return document.documentElement.classList.contains("dark");
}

export function LoadingDot() {
  return (
    <div style={{ display: "flex", alignItems: "center" }}>
      <span 
        style={{
          height: 8,
          width: 8,
          borderRadius: "50%",
          backgroundColor: "currentColor",
          animation: "scaleUpDown 1s ease-in-out infinite",
        }}
      />
      <style>{`
        @keyframes scaleUpDown {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.8); }
        }
      `}</style>
    </div>
  );
}

export function UserMessageBubble({ content, imageUrl, index }: UserBubbleProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState(600);
  const [dark, setDark] = useState(false);

  useEffect(() => {
    const updateWidth = () => {
      if (containerRef.current?.parentElement) {
        setContainerWidth(containerRef.current.parentElement.offsetWidth);
      } else {
        setContainerWidth(window.innerWidth - 64);
      }
    };
    const updateTheme = () => setDark(isDarkMode());
    
    updateWidth();
    updateTheme();
    
    window.addEventListener("resize", updateWidth);
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ["class"] });
    
    const resizeObserver = new ResizeObserver(updateWidth);
    if (containerRef.current?.parentElement) {
      resizeObserver.observe(containerRef.current.parentElement);
    }
    
    return () => {
      window.removeEventListener("resize", updateWidth);
      observer.disconnect();
      resizeObserver.disconnect();
    };
  }, []);

  const hasImage = !!imageUrl;
  const bubbleWidth = calculateBubbleWidth(content.length, containerWidth, hasImage);
  const maxWidth = Math.floor(containerWidth * USER_BUBBLE_CONFIG.width.maxPercent);
  const { colors, padding, borderRadius, typography, height } = USER_BUBBLE_CONFIG;

  const containerStyle: React.CSSProperties = {
    display: "flex",
    justifyContent: "flex-end",
    width: "100%",
  };

  const bubbleStyle: React.CSSProperties = {
    backgroundColor: dark ? colors.backgroundDark : colors.backgroundLight,
    color: dark ? colors.textDark : colors.textLight,
    width: "auto",
    minWidth: USER_BUBBLE_CONFIG.width.min,
    maxWidth: maxWidth,
    minHeight: height.min,
    paddingLeft: padding.horizontal,
    paddingRight: padding.horizontal,
    paddingTop: padding.vertical,
    paddingBottom: padding.vertical,
    borderRadius: borderRadius.bubble,
    wordBreak: "break-word",
    overflowWrap: "break-word",
  };

  const imageStyle: React.CSSProperties = {
    maxWidth: "100%",
    maxHeight: height.imageMaxHeight,
    marginBottom: height.imageMarginBottom,
    borderRadius: borderRadius.image,
    objectFit: "contain",
  };

  const textStyle: React.CSSProperties = {
    whiteSpace: "pre-wrap",
    fontSize: typography.fontSize,
    lineHeight: `${height.lineHeight}px`,
    fontWeight: typography.fontWeight,
    margin: 0,
  };

  return (
    <div ref={containerRef} style={containerStyle} data-testid={`user-message-container-${index}`}>
      <div style={bubbleStyle} data-testid={`user-message-bubble-${index}`}>
        {imageUrl && (
          <img 
            src={imageUrl} 
            alt="Attached"
            style={imageStyle}
            data-testid={`user-message-image-${index}`}
            loading="lazy"
          />
        )}
        <p style={textStyle} data-testid={`user-message-text-${index}`}>
          {content}
        </p>
      </div>
    </div>
  );
}

export function AssistantMessageBubble({ content }: AssistantBubbleProps) {
  const containerStyle: React.CSSProperties = {
    width: "100%",
    minWidth: 0,
    flex: 1,
    overflow: "hidden",
  };

  return (
    <div style={containerStyle}>
      <Markdown className="prose prose-sm prose-h1:text-xl prose-h2:text-lg prose-h3:text-base prose-h4:text-sm prose-h5:text-xs prose-h6:text-xs dark:prose-invert max-w-none text-[15px] font-medium text-black dark:text-white break-words overflow-hidden">
        {content}
      </Markdown>
    </div>
  );
}
```
